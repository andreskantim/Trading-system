<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RSI - 14.000, 30.000, 70.000</title>
    <script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #0d1117;
            color: #c9d1d9;
            overflow: hidden;
        }
        #container { 
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
        }
        #main-chart { flex: 7; }
        #sub-chart { flex: 3; border-top: 1px solid #30363d; }
        .info {
            position: absolute;
            top: 12px;
            left: 12px;
            background: rgba(13, 17, 23, 0.95);
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 14px;
            z-index: 1000;
            border: 1px solid #30363d;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div class="info"><strong>RSI</strong> | 14.000, 30.000, 70.000</div>
    <div id="container">
        <div id="main-chart"></div>
        <div id='sub-chart'></div>
    </div>
    <script>
        // Cargar todos los datos desde archivos JSON
        Promise.all([
            fetch('chart_data.json').then(r => r.json()),
            fetch('indicators_in.json').then(r => r.json()),
            fetch('indicators_off.json').then(r => r.json()),
            fetch('markers.json').then(r => r.json())
        ]).then(([ohlcData, indicatorsIn, indicatorsOff, markers]) => {
            console.log('OHLC:', ohlcData.length, 'points');
            console.log('In-price indicators:', indicatorsIn.length);
            console.log('Off-price indicators:', indicatorsOff.length);
            console.log('Markers:', markers.length);
            
            // Main chart
            const mainChart = LightweightCharts.createChart(document.getElementById('main-chart'), {
                width: window.innerWidth,
                height: window.innerHeight * 0.7,
                layout: {
                    background: { color: '#0d1117' },
                    textColor: '#c9d1d9',
                },
                grid: {
                    vertLines: { color: 'rgba(197, 203, 206, 0.1)' },
                    horzLines: { color: 'rgba(197, 203, 206, 0.1)' },
                },
                crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                timeScale: {
                    timeVisible: true,
                    secondsVisible: false,
                    fixLeftEdge: false,
                    fixRightEdge: false,
                },
            });
            
            // Candlestick series (API v4)
            const candleSeries = mainChart.addCandlestickSeries({
                upColor: '#26a69a',
                downColor: '#ef5350',
                borderUpColor: '#26a69a',
                borderDownColor: '#ef5350',
                wickUpColor: '#26a69a',
                wickDownColor: '#ef5350',
            });
            candleSeries.setData(ohlcData);
            
            // Markers
            if (markers.length > 0) {
                console.log('üìç Aplicando', markers.length, 'markers');
                candleSeries.setMarkers(markers);
            }
            
            // In-price indicators (API v4)
            indicatorsIn.forEach(ind => {
                const line = mainChart.addLineSeries({
                    color: ind.color,
                    lineWidth: 2,
                    title: ind.name,
                });
                line.setData(ind.data);
            });
            
            
            // Subchart
            const subChart = LightweightCharts.createChart(document.getElementById('sub-chart'), {
                width: window.innerWidth,
                height: window.innerHeight * 0.3,
                layout: {
                    background: { color: '#0d1117' },
                    textColor: '#c9d1d9',
                },
                grid: {
                    vertLines: { color: 'rgba(197, 203, 206, 0.1)' },
                    horzLines: { color: 'rgba(197, 203, 206, 0.1)' },
                },
                timeScale: {
                    timeVisible: true,
                    secondsVisible: false,
                    fixLeftEdge: false,
                    fixRightEdge: false,
                },
            });

            // Off-price indicators (API v4)
            indicatorsOff.forEach(ind => {
                const line = subChart.addLineSeries({
                    color: ind.color,
                    lineWidth: 2,
                    title: ind.name,
                    priceLineVisible: false,
                    lastValueVisible: true,
                });
                
                // Solo setear datos si hay datos v√°lidos
                if (ind.data && ind.data.length > 0) {
                    line.setData(ind.data);
                    console.log('‚úì Indicator', ind.name, ':', ind.data.length, 'points from', 
                               new Date(ind.data[0].time * 1000).toISOString().split('T')[0], 
                               'to', new Date(ind.data[ind.data.length-1].time * 1000).toISOString().split('T')[0]);
                }
            });
            
            // Sync timeframes using TIME-BASED synchronization (not logical index)
            // This ensures proper alignment even when indicator data starts later than OHLC
            let isSyncing = false;

            mainChart.timeScale().subscribeVisibleTimeRangeChange(timeRange => {
                if (isSyncing || !timeRange) return;
                isSyncing = true;
                subChart.timeScale().setVisibleRange(timeRange);
                isSyncing = false;
            });

            subChart.timeScale().subscribeVisibleTimeRangeChange(timeRange => {
                if (isSyncing || !timeRange) return;
                isSyncing = true;
                mainChart.timeScale().setVisibleRange(timeRange);
                isSyncing = false;
            });

            // Initial sync: fit main chart to full data range, then sync subchart
            mainChart.timeScale().fitContent();
            setTimeout(() => {
                const mainRange = mainChart.timeScale().getVisibleRange();
                if (mainRange) {
                    subChart.timeScale().setVisibleRange(mainRange);
                }
            }, 100);
            
            
            
            // Responsive
            window.addEventListener('resize', () => {
                mainChart.applyOptions({ 
                    width: window.innerWidth,
                    height: window.innerHeight * 0.7
                });
                subChart.applyOptions({ width: window.innerWidth, height: window.innerHeight * 0.3 });
            });
            
            console.log('‚úÖ Chart loaded successfully!');
        }).catch(error => {
            console.error('‚ùå Error loading data:', error);
        });
    </script>
</body>
</html>